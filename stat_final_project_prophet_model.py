# -*- coding: utf-8 -*-
"""Stat_Final_project_Prophet_Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S1Vw5EQ7Jq0dkvpmBGJsZdtgz1yKTFhk
"""

import pandas_datareader.data as web
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
import scipy.stats as scs
from fbprophet import Prophet
from fbprophet.plot import plot_plotly

import pandas as pd
import os
dji = web.DataReader('^DJI', data_source = 'yahoo', start = '2000-01-01')
# print(dji.head())
# print('\n')
# print(dji.shape)
dji_series = dji['Adj Close']


#Calculate the simple and log returns using the adj close prices:
dji['simple_rtn'] = dji_series.pct_change()  # Calculating percent change
# print(dji['simple_rtn'].tail())
dji['log_rtn'] = np.log(dji_series/dji_series.shift(1))  # Calculating log return

fig, ax = plt.subplots(3, 1, figsize=(14, 10), sharex=True)  # Plotting Closing prices, Simple return and Log return
# measuring variability of stock trading schemes
dji_series.plot(ax=ax[0],color = 'orange')
ax[0].set(title = 'DJIA time series', ylabel = 'Dow Jones Adj Close price ($)')
dji.simple_rtn.plot(ax=ax[1])
ax[1].set(ylabel = 'Simple returns (%)')
dji.log_rtn.plot(ax=ax[2],color = 'purple')
ax[2].set(xlabel = 'Date', ylabel = 'Log returns (%)')
# plt.show()

#Calculate the rolling mean and standard deviation:
df_rolling = dji[['simple_rtn']].rolling(window=21).agg(['mean', 'var']) 


df_rolling.columns = df_rolling.columns.droplevel()


# Histogram of log returns and Q-Q Plot
r_range = np.linspace(min(dji['log_rtn'].dropna()), max(dji['log_rtn'].dropna()), num=1000)
mu = dji['log_rtn'].dropna().mean()
sigma = dji['log_rtn'].dropna().std()
norm_pdf = scs.norm.pdf(r_range, loc=mu, scale=sigma)#Plot the histogram and the Q-Q plot
fig, ax = plt.subplots(1, 2, figsize=(12, 8))# histogram
sns.distplot(dji['log_rtn'].dropna(), kde=False, norm_hist=True, ax=ax[0])
ax[0].set_title('Distribution of DJI returns', fontsize=16)
ax[0].plot(r_range, norm_pdf, 'g', lw=2, label=f'N({mu:.2f}, {sigma**2:.4f})')
ax[0].legend(loc='upper left');# Q-Q plot
qq = sm.qqplot(dji['log_rtn'].dropna().values, line='s', ax=ax[1])
ax[1].set_title('Q-Q plot', fontsize = 16)
plt.show()

N_LAGS = 50
SIGNIFICANCE_LEVEL = 0.05
fig, ax = plt.subplots(2, 1, figsize=(12, 8))
sm.graphics.tsa.plot_acf(dji['log_rtn'].dropna() ** 2, lags=N_LAGS,alpha=SIGNIFICANCE_LEVEL, ax = ax[0])

ax[0].set(title='Autocorrelation Plots', ylabel='Squared Returns')

sm.graphics.tsa.plot_acf(dji['log_rtn'].dropna(), lags=N_LAGS,alpha=SIGNIFICANCE_LEVEL, ax = ax[1])

ax[1].set(ylabel='Returns',xlabel='Lag')
plt.show()

prophet = dji_series.reset_index()
prophet.rename(columns={'Date':'ds','Adj Close':'y'},inplace=True)
prophet = prophet[['ds','y']]
train_percent = 0.95

# prepare train and test sets
train_size = int(prophet.shape[0]*train_percent)
train = prophet.iloc[:train_size]
test = prophet.iloc[train_size:]
model_prophet = Prophet(daily_seasonality = True) # build a prophet model
model_prophet.fit(train) # fit the model

# prepare a future dataframe
future_dates = model_prophet.make_future_dataframe(periods=test.shape[0])
forecast = model_prophet.predict(future_dates) # forecast values
model_prophet.plot(forecast) # plot for prediction
plt.title('Prediction on Test data')

forecast.set_index('ds', inplace=True, drop=True)
forecast.index = pd.to_datetime(forecast.index)
prophet.set_index('ds', inplace=True, drop=True)
prophet.index = pd.to_datetime(prophet.index)

# Final Plot
plt.plot(forecast['yhat'],c='r',label='Forecast')
plt.plot(forecast.yhat_lower.iloc[train_size:], linestyle='--',c='b',alpha=0.3, label='Confidence Interval')
plt.plot(forecast.yhat_upper.iloc[train_size:], linestyle='--',c='b',alpha=0.3)
plt.plot(prophet['y'],c='g',label='True Data')
plt.legend()
plt.title('Prophet Model Forecast vs Actutal Data')